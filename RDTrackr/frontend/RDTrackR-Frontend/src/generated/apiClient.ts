//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IApiClient {

    /**
     * @return OK
     */
    adminAll(signal?: AbortSignal): Promise<ResponseShortUserJson[]>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    admin(id: number, body?: RequestAdminUpdateUserJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    toggle(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param type (optional) 
     * @param search (optional) 
     * @return OK
     */
    logs(type?: string | undefined, search?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: RequestLoginJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body?: string | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return Accepted
     */
    codeResetPassword(email: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    resetPassword(body?: RequestResetYourPasswordJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param warehouseId (optional) 
     * @param type (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    movementAll(warehouseId?: number | undefined, type?: MovementType | undefined, startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<ResponseMovementJson[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    movement(body?: RequestRegisterMovementJson | undefined, signal?: AbortSignal): Promise<ResponseMovementJson>;

    /**
     * @return OK
     */
    notifications(signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    read(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    overview(signal?: AbortSignal): Promise<ResponseOverviewJson>;

    /**
     * @param body (optional) 
     * @return Created
     */
    productPOST(body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<ResponseProductJson>;

    /**
     * @return OK
     */
    productAll(signal?: AbortSignal): Promise<ResponseProductJson[]>;

    /**
     * @return OK
     */
    productGET(id: number, signal?: AbortSignal): Promise<ResponseProductJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    productPUT(id: number, body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    productDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    purchaseorderPOST(body?: RequestCreatePurchaseOrderJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    purchaseorderGET(signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    purchaseorderPUT(id: number, body?: RequestUpdatePurchaseOrderStatusJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    purchaseorderDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    purchaseorderGET2(id: string, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson>;

    /**
     * @param body (optional) 
     * @return OK
     */
    items(id: number, body?: RequestUpdatePurchaseOrderItemsJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    replenishment(signal?: AbortSignal): Promise<ResponseReplenishmentItemJson[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    generatePo(body?: RequestGeneratePoFromReplenishmentJson | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson>;

    /**
     * @return OK
     */
    reports(signal?: AbortSignal): Promise<ResponseReportsJson>;

    /**
     * @param body (optional) 
     * @return Created
     */
    stockitem(body?: RequestRegisterStockItemJson | undefined, signal?: AbortSignal): Promise<ResponseStockItemJson>;

    /**
     * @return OK
     */
    stockitemAll(signal?: AbortSignal): Promise<ResponseStockItemJson[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    supplierPOST(body?: RequestRegisterSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson>;

    /**
     * @return OK
     */
    supplierAll(signal?: AbortSignal): Promise<ResponseSupplierJson[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    supplierPUT(id: number, body?: RequestUpdateSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson>;

    /**
     * @return No Content
     */
    supplierDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    refreshToken(body?: RequestNewTokenJson | undefined, signal?: AbortSignal): Promise<ResponseTokensJson>;

    /**
     * @param body (optional) 
     * @return Created
     */
    userPOST(body?: RequestRegisterUserJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson>;

    /**
     * @return OK
     */
    userGET(signal?: AbortSignal): Promise<ResponseUserProfileJson>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    userPUT(body?: RequestUpdateUserJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return No Content
     */
    userDELETE(signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    changePassword(body?: RequestChangePasswordJson | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    warehouseAll(signal?: AbortSignal): Promise<ResponseWarehouseJson[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    warehousePOST(body?: RequestRegisterWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson>;

    /**
     * @param body (optional) 
     * @return OK
     */
    warehousePUT(id: number, body?: RequestUpdateWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson>;

    /**
     * @return No Content
     */
    warehouseDELETE(id: number, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    warehouseGET(id: number, signal?: AbortSignal): Promise<ResponseWarehouseJson>;
}

export class ApiClient implements IApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    adminAll(signal?: AbortSignal): Promise<ResponseShortUserJson[]> {
        let url_ = this.baseUrl + "/users/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdminAll(_response);
        });
    }

    protected processAdminAll(response: Response): Promise<ResponseShortUserJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseShortUserJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseShortUserJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    admin(id: number, body?: RequestAdminUpdateUserJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/users/admin/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdmin(_response);
        });
    }

    protected processAdmin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    toggle(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/users/admin/{id}/toggle";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PATCH",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processToggle(_response);
        });
    }

    protected processToggle(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param type (optional) 
     * @param search (optional) 
     * @return OK
     */
    logs(type?: string | undefined, search?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/auditlog/audit/logs?";
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (search === null)
            throw new globalThis.Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogs(_response);
        });
    }

    protected processLogs(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body?: RequestLoginJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<ResponseRegisterUserJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseRegisterUserJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ResponseErrorJson.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseRegisterUserJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body?: string | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Accepted
     */
    codeResetPassword(email: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/code-reset-password/{email}";
        if (email === undefined || email === null)
            throw new globalThis.Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCodeResetPassword(_response);
        });
    }

    protected processCodeResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    resetPassword(body?: RequestResetYourPasswordJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/login/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param warehouseId (optional) 
     * @param type (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return OK
     */
    movementAll(warehouseId?: number | undefined, type?: MovementType | undefined, startDate?: Date | undefined, endDate?: Date | undefined, signal?: AbortSignal): Promise<ResponseMovementJson[]> {
        let url_ = this.baseUrl + "/movement?";
        if (warehouseId === null)
            throw new globalThis.Error("The parameter 'warehouseId' cannot be null.");
        else if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&";
        if (type === null)
            throw new globalThis.Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        if (startDate === null)
            throw new globalThis.Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new globalThis.Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMovementAll(_response);
        });
    }

    protected processMovementAll(response: Response): Promise<ResponseMovementJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseMovementJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseMovementJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    movement(body?: RequestRegisterMovementJson | undefined, signal?: AbortSignal): Promise<ResponseMovementJson> {
        let url_ = this.baseUrl + "/movement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMovement(_response);
        });
    }

    protected processMovement(response: Response): Promise<ResponseMovementJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseMovementJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseMovementJson>(null as any);
    }

    /**
     * @return OK
     */
    notifications(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/notifications/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNotifications(_response);
        });
    }

    protected processNotifications(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    read(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/notifications/notifications/{id}/read";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRead(_response);
        });
    }

    protected processRead(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    overview(signal?: AbortSignal): Promise<ResponseOverviewJson> {
        let url_ = this.baseUrl + "/overview";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOverview(_response);
        });
    }

    protected processOverview(response: Response): Promise<ResponseOverviewJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseOverviewJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseOverviewJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    productPOST(body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<ResponseProductJson> {
        let url_ = this.baseUrl + "/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductPOST(_response);
        });
    }

    protected processProductPOST(response: Response): Promise<ResponseProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseProductJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseProductJson>(null as any);
    }

    /**
     * @return OK
     */
    productAll(signal?: AbortSignal): Promise<ResponseProductJson[]> {
        let url_ = this.baseUrl + "/product";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductAll(_response);
        });
    }

    protected processProductAll(response: Response): Promise<ResponseProductJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseProductJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseProductJson[]>(null as any);
    }

    /**
     * @return OK
     */
    productGET(id: number, signal?: AbortSignal): Promise<ResponseProductJson> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductGET(_response);
        });
    }

    protected processProductGET(response: Response): Promise<ResponseProductJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseProductJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ResponseErrorJson.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseProductJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    productPUT(id: number, body?: RequestRegisterProductJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductPUT(_response);
        });
    }

    protected processProductPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    productDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processProductDELETE(_response);
        });
    }

    protected processProductDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    purchaseorderPOST(body?: RequestCreatePurchaseOrderJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderPOST(_response);
        });
    }

    protected processPurchaseorderPOST(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    purchaseorderGET(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderGET(_response);
        });
    }

    protected processPurchaseorderGET(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    purchaseorderPUT(id: number, body?: RequestUpdatePurchaseOrderStatusJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderPUT(_response);
        });
    }

    protected processPurchaseorderPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    purchaseorderDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderDELETE(_response);
        });
    }

    protected processPurchaseorderDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    purchaseorderGET2(id: string, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson> {
        let url_ = this.baseUrl + "/purchaseorder/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPurchaseorderGET2(_response);
        });
    }

    protected processPurchaseorderGET2(response: Response): Promise<ResponsePurchaseOrderJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponsePurchaseOrderJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ResponseErrorJson.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePurchaseOrderJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    items(id: number, body?: RequestUpdatePurchaseOrderItemsJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/purchaseorder/{id}/items";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processItems(_response);
        });
    }

    protected processItems(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    replenishment(signal?: AbortSignal): Promise<ResponseReplenishmentItemJson[]> {
        let url_ = this.baseUrl + "/replenishment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReplenishment(_response);
        });
    }

    protected processReplenishment(response: Response): Promise<ResponseReplenishmentItemJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseReplenishmentItemJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseReplenishmentItemJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    generatePo(body?: RequestGeneratePoFromReplenishmentJson | undefined, signal?: AbortSignal): Promise<ResponsePurchaseOrderJson> {
        let url_ = this.baseUrl + "/replenishment/generate-po";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGeneratePo(_response);
        });
    }

    protected processGeneratePo(response: Response): Promise<ResponsePurchaseOrderJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponsePurchaseOrderJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponsePurchaseOrderJson>(null as any);
    }

    /**
     * @return OK
     */
    reports(signal?: AbortSignal): Promise<ResponseReportsJson> {
        let url_ = this.baseUrl + "/reports";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReports(_response);
        });
    }

    protected processReports(response: Response): Promise<ResponseReportsJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseReportsJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseReportsJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    stockitem(body?: RequestRegisterStockItemJson | undefined, signal?: AbortSignal): Promise<ResponseStockItemJson> {
        let url_ = this.baseUrl + "/stockitem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStockitem(_response);
        });
    }

    protected processStockitem(response: Response): Promise<ResponseStockItemJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseStockItemJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseStockItemJson>(null as any);
    }

    /**
     * @return OK
     */
    stockitemAll(signal?: AbortSignal): Promise<ResponseStockItemJson[]> {
        let url_ = this.baseUrl + "/stockitem";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStockitemAll(_response);
        });
    }

    protected processStockitemAll(response: Response): Promise<ResponseStockItemJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseStockItemJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseStockItemJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    supplierPOST(body?: RequestRegisterSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson> {
        let url_ = this.baseUrl + "/supplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierPOST(_response);
        });
    }

    protected processSupplierPOST(response: Response): Promise<ResponseSupplierJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseSupplierJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierJson>(null as any);
    }

    /**
     * @return OK
     */
    supplierAll(signal?: AbortSignal): Promise<ResponseSupplierJson[]> {
        let url_ = this.baseUrl + "/supplier";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierAll(_response);
        });
    }

    protected processSupplierAll(response: Response): Promise<ResponseSupplierJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseSupplierJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    supplierPUT(id: number, body?: RequestUpdateSupplierJson | undefined, signal?: AbortSignal): Promise<ResponseSupplierJson> {
        let url_ = this.baseUrl + "/supplier/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierPUT(_response);
        });
    }

    protected processSupplierPUT(response: Response): Promise<ResponseSupplierJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseSupplierJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseSupplierJson>(null as any);
    }

    /**
     * @return No Content
     */
    supplierDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/supplier/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSupplierDELETE(_response);
        });
    }

    protected processSupplierDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    refreshToken(body?: RequestNewTokenJson | undefined, signal?: AbortSignal): Promise<ResponseTokensJson> {
        let url_ = this.baseUrl + "/token/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: Response): Promise<ResponseTokensJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseTokensJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseTokensJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    userPOST(body?: RequestRegisterUserJson | undefined, signal?: AbortSignal): Promise<ResponseRegisterUserJson> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserPOST(_response);
        });
    }

    protected processUserPOST(response: Response): Promise<ResponseRegisterUserJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseRegisterUserJson.fromJS(resultData201);
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseRegisterUserJson>(null as any);
    }

    /**
     * @return OK
     */
    userGET(signal?: AbortSignal): Promise<ResponseUserProfileJson> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserGET(_response);
        });
    }

    protected processUserGET(response: Response): Promise<ResponseUserProfileJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseUserProfileJson.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseUserProfileJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    userPUT(body?: RequestUpdateUserJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserPUT(_response);
        });
    }

    protected processUserPUT(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return No Content
     */
    userDELETE(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUserDELETE(_response);
        });
    }

    protected processUserDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    changePassword(body?: RequestChangePasswordJson | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/user/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    warehouseAll(signal?: AbortSignal): Promise<ResponseWarehouseJson[]> {
        let url_ = this.baseUrl + "/warehouse";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehouseAll(_response);
        });
    }

    protected processWarehouseAll(response: Response): Promise<ResponseWarehouseJson[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ResponseWarehouseJson.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    warehousePOST(body?: RequestRegisterWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson> {
        let url_ = this.baseUrl + "/warehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousePOST(_response);
        });
    }

    protected processWarehousePOST(response: Response): Promise<ResponseWarehouseJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ResponseWarehouseJson.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    warehousePUT(id: number, body?: RequestUpdateWarehouseJson | undefined, signal?: AbortSignal): Promise<ResponseWarehouseJson> {
        let url_ = this.baseUrl + "/warehouse/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehousePUT(_response);
        });
    }

    protected processWarehousePUT(response: Response): Promise<ResponseWarehouseJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseWarehouseJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ResponseErrorJson.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson>(null as any);
    }

    /**
     * @return No Content
     */
    warehouseDELETE(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/warehouse/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehouseDELETE(_response);
        });
    }

    protected processWarehouseDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ResponseErrorJson.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    warehouseGET(id: number, signal?: AbortSignal): Promise<ResponseWarehouseJson> {
        let url_ = this.baseUrl + "/warehouse/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWarehouseGET(_response);
        });
    }

    protected processWarehouseGET(response: Response): Promise<ResponseWarehouseJson> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResponseWarehouseJson.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResponseWarehouseJson>(null as any);
    }
}

export type MovementType = "INBOUND" | "OUTBOUND" | "ADJUST";

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class ReplenishmentPoItemJson implements IReplenishmentPoItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IReplenishmentPoItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): ReplenishmentPoItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ReplenishmentPoItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IReplenishmentPoItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;
}

export class RequestAdminUpdateUserJson implements IRequestAdminUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;
    active?: boolean;

    constructor(data?: IRequestAdminUpdateUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.active = _data["active"];
        }
    }

    static fromJS(data: any): RequestAdminUpdateUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestAdminUpdateUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["active"] = this.active;
        return data;
    }
}

export interface IRequestAdminUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;
    active?: boolean;
}

export class RequestChangePasswordJson implements IRequestChangePasswordJson {
    password?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IRequestChangePasswordJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): RequestChangePasswordJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestChangePasswordJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IRequestChangePasswordJson {
    password?: string | undefined;
    newPassword?: string | undefined;
}

export class RequestCreatePurchaseOrderItemJson implements IRequestCreatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IRequestCreatePurchaseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): RequestCreatePurchaseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCreatePurchaseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IRequestCreatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;
}

export class RequestCreatePurchaseOrderJson implements IRequestCreatePurchaseOrderJson {
    supplierId?: number;
    items?: RequestCreatePurchaseOrderItemJson[] | undefined;

    constructor(data?: IRequestCreatePurchaseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestCreatePurchaseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestCreatePurchaseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCreatePurchaseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestCreatePurchaseOrderJson {
    supplierId?: number;
    items?: RequestCreatePurchaseOrderItemJson[] | undefined;
}

export class RequestGeneratePoFromReplenishmentJson implements IRequestGeneratePoFromReplenishmentJson {
    supplierId?: number;
    notes?: string | undefined;
    items?: ReplenishmentPoItemJson[] | undefined;

    constructor(data?: IRequestGeneratePoFromReplenishmentJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierId = _data["supplierId"];
            this.notes = _data["notes"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReplenishmentPoItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestGeneratePoFromReplenishmentJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestGeneratePoFromReplenishmentJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierId"] = this.supplierId;
        data["notes"] = this.notes;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestGeneratePoFromReplenishmentJson {
    supplierId?: number;
    notes?: string | undefined;
    items?: ReplenishmentPoItemJson[] | undefined;
}

export class RequestLoginJson implements IRequestLoginJson {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRequestLoginJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RequestLoginJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestLoginJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRequestLoginJson {
    email?: string | undefined;
    password?: string | undefined;
}

export class RequestNewTokenJson implements IRequestNewTokenJson {
    refreshToken?: string | undefined;
    tokenId?: string | undefined;

    constructor(data?: IRequestNewTokenJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
            this.tokenId = _data["tokenId"];
        }
    }

    static fromJS(data: any): RequestNewTokenJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestNewTokenJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        data["tokenId"] = this.tokenId;
        return data;
    }
}

export interface IRequestNewTokenJson {
    refreshToken?: string | undefined;
    tokenId?: string | undefined;
}

export class RequestRegisterMovementJson implements IRequestRegisterMovementJson {
    reference?: string | undefined;
    productId?: number;
    warehouseId?: number;
    type?: MovementType;
    quantity?: number;

    constructor(data?: IRequestRegisterMovementJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reference = _data["reference"];
            this.productId = _data["productId"];
            this.warehouseId = _data["warehouseId"];
            this.type = _data["type"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): RequestRegisterMovementJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterMovementJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["type"] = this.type;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IRequestRegisterMovementJson {
    reference?: string | undefined;
    productId?: number;
    warehouseId?: number;
    type?: MovementType;
    quantity?: number;
}

export class RequestRegisterProductJson implements IRequestRegisterProductJson {
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    stock?: number;
    reorderPoint?: number;

    constructor(data?: IRequestRegisterProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.uoM = _data["uoM"];
            this.price = _data["price"];
            this.stock = _data["stock"];
            this.reorderPoint = _data["reorderPoint"];
        }
    }

    static fromJS(data: any): RequestRegisterProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["category"] = this.category;
        data["uoM"] = this.uoM;
        data["price"] = this.price;
        data["stock"] = this.stock;
        data["reorderPoint"] = this.reorderPoint;
        return data;
    }
}

export interface IRequestRegisterProductJson {
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    stock?: number;
    reorderPoint?: number;
}

export class RequestRegisterStockItemJson implements IRequestRegisterStockItemJson {
    productId?: number;
    warehouseId?: number;
    quantity?: number;

    constructor(data?: IRequestRegisterStockItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.warehouseId = _data["warehouseId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): RequestRegisterStockItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterStockItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["warehouseId"] = this.warehouseId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IRequestRegisterStockItemJson {
    productId?: number;
    warehouseId?: number;
    quantity?: number;
}

export class RequestRegisterSupplierJson implements IRequestRegisterSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;

    constructor(data?: IRequestRegisterSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.contact = _data["contact"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): RequestRegisterSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["contact"] = this.contact;
        data["address"] = this.address;
        return data;
    }
}

export interface IRequestRegisterSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;
}

export class RequestRegisterUserJson implements IRequestRegisterUserJson {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRequestRegisterUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RequestRegisterUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRequestRegisterUserJson {
    name?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export class RequestRegisterWarehouseJson implements IRequestRegisterWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;

    constructor(data?: IRequestRegisterWarehouseJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.capacity = _data["capacity"];
            this.items = _data["items"];
        }
    }

    static fromJS(data: any): RequestRegisterWarehouseJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestRegisterWarehouseJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["capacity"] = this.capacity;
        data["items"] = this.items;
        return data;
    }
}

export interface IRequestRegisterWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
}

export class RequestResetYourPasswordJson implements IRequestResetYourPasswordJson {
    email?: string | undefined;
    code?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRequestResetYourPasswordJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.code = _data["code"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RequestResetYourPasswordJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestResetYourPasswordJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["code"] = this.code;
        data["password"] = this.password;
        return data;
    }
}

export interface IRequestResetYourPasswordJson {
    email?: string | undefined;
    code?: string | undefined;
    password?: string | undefined;
}

export class RequestUpdatePurchaseOrderItemJson implements IRequestUpdatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IRequestUpdatePurchaseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): RequestUpdatePurchaseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdatePurchaseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IRequestUpdatePurchaseOrderItemJson {
    productId?: number;
    quantity?: number;
    unitPrice?: number;
}

export class RequestUpdatePurchaseOrderItemsJson implements IRequestUpdatePurchaseOrderItemsJson {
    items?: RequestUpdatePurchaseOrderItemJson[] | undefined;

    constructor(data?: IRequestUpdatePurchaseOrderItemsJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestUpdatePurchaseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestUpdatePurchaseOrderItemsJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdatePurchaseOrderItemsJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IRequestUpdatePurchaseOrderItemsJson {
    items?: RequestUpdatePurchaseOrderItemJson[] | undefined;
}

export class RequestUpdatePurchaseOrderStatusJson implements IRequestUpdatePurchaseOrderStatusJson {
    status?: string | undefined;

    constructor(data?: IRequestUpdatePurchaseOrderStatusJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RequestUpdatePurchaseOrderStatusJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdatePurchaseOrderStatusJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IRequestUpdatePurchaseOrderStatusJson {
    status?: string | undefined;
}

export class RequestUpdateSupplierJson implements IRequestUpdateSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;

    constructor(data?: IRequestUpdateSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.contact = _data["contact"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): RequestUpdateSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["contact"] = this.contact;
        data["address"] = this.address;
        return data;
    }
}

export interface IRequestUpdateSupplierJson {
    name?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    contact?: string | undefined;
    address?: string | undefined;
}

export class RequestUpdateUserJson implements IRequestUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;

    constructor(data?: IRequestUpdateUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): RequestUpdateUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IRequestUpdateUserJson {
    name?: string | undefined;
    email?: string | undefined;
}

export class RequestUpdateWarehouseJson implements IRequestUpdateWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;

    constructor(data?: IRequestUpdateWarehouseJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.location = _data["location"];
            this.capacity = _data["capacity"];
            this.items = _data["items"];
        }
    }

    static fromJS(data: any): RequestUpdateWarehouseJson {
        data = typeof data === 'object' ? data : {};
        let result = new RequestUpdateWarehouseJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["location"] = this.location;
        data["capacity"] = this.capacity;
        data["items"] = this.items;
        return data;
    }
}

export interface IRequestUpdateWarehouseJson {
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
}

export class ResponseErrorJson implements IResponseErrorJson {
    errors?: string[] | undefined;
    tokenExpired?: boolean;

    constructor(data?: IResponseErrorJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
            this.tokenExpired = _data["tokenExpired"];
        }
    }

    static fromJS(data: any): ResponseErrorJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseErrorJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        data["tokenExpired"] = this.tokenExpired;
        return data;
    }
}

export interface IResponseErrorJson {
    errors?: string[] | undefined;
    tokenExpired?: boolean;
}

export class ResponseMovementJson implements IResponseMovementJson {
    id?: string;
    reference?: string | undefined;
    product?: string | undefined;
    warehouse?: string | undefined;
    type?: string | undefined;
    quantity?: number;
    createdAt?: Date;
    createdByName?: string | undefined;

    constructor(data?: IResponseMovementJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reference = _data["reference"];
            this.product = _data["product"];
            this.warehouse = _data["warehouse"];
            this.type = _data["type"];
            this.quantity = _data["quantity"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseMovementJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseMovementJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reference"] = this.reference;
        data["product"] = this.product;
        data["warehouse"] = this.warehouse;
        data["type"] = this.type;
        data["quantity"] = this.quantity;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseMovementJson {
    id?: string;
    reference?: string | undefined;
    product?: string | undefined;
    warehouse?: string | undefined;
    type?: string | undefined;
    quantity?: number;
    createdAt?: Date;
    createdByName?: string | undefined;
}

export class ResponseOverviewJson implements IResponseOverviewJson {
    totalProducts?: number;
    totalWarehouses?: number;
    totalMovements?: number;
    totalStockItems?: number;
    totalInventoryQuantity?: number;

    constructor(data?: IResponseOverviewJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProducts = _data["totalProducts"];
            this.totalWarehouses = _data["totalWarehouses"];
            this.totalMovements = _data["totalMovements"];
            this.totalStockItems = _data["totalStockItems"];
            this.totalInventoryQuantity = _data["totalInventoryQuantity"];
        }
    }

    static fromJS(data: any): ResponseOverviewJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseOverviewJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProducts"] = this.totalProducts;
        data["totalWarehouses"] = this.totalWarehouses;
        data["totalMovements"] = this.totalMovements;
        data["totalStockItems"] = this.totalStockItems;
        data["totalInventoryQuantity"] = this.totalInventoryQuantity;
        return data;
    }
}

export interface IResponseOverviewJson {
    totalProducts?: number;
    totalWarehouses?: number;
    totalMovements?: number;
    totalStockItems?: number;
    totalInventoryQuantity?: number;
}

export class ResponseProductJson implements IResponseProductJson {
    id?: string;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    stock?: number;
    reorderPoint?: number;
    updatedAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;

    constructor(data?: IResponseProductJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.uoM = _data["uoM"];
            this.price = _data["price"];
            this.stock = _data["stock"];
            this.reorderPoint = _data["reorderPoint"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseProductJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseProductJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["category"] = this.category;
        data["uoM"] = this.uoM;
        data["price"] = this.price;
        data["stock"] = this.stock;
        data["reorderPoint"] = this.reorderPoint;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseProductJson {
    id?: string;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uoM?: string | undefined;
    price?: number;
    stock?: number;
    reorderPoint?: number;
    updatedAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
}

export class ResponsePurchaseOrderItemJson implements IResponsePurchaseOrderItemJson {
    productName?: string | undefined;
    quantity?: number;
    unitPrice?: number;

    constructor(data?: IResponsePurchaseOrderItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productName = _data["productName"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): ResponsePurchaseOrderItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePurchaseOrderItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productName"] = this.productName;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IResponsePurchaseOrderItemJson {
    productName?: string | undefined;
    quantity?: number;
    unitPrice?: number;
}

export class ResponsePurchaseOrderJson implements IResponsePurchaseOrderJson {
    id?: string;
    number?: string | undefined;
    supplierName?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    createdByName?: string | undefined;
    items?: ResponsePurchaseOrderItemJson[] | undefined;

    constructor(data?: IResponsePurchaseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.supplierName = _data["supplierName"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByName = _data["createdByName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ResponsePurchaseOrderItemJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponsePurchaseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsePurchaseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["supplierName"] = this.supplierName;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByName"] = this.createdByName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResponsePurchaseOrderJson {
    id?: string;
    number?: string | undefined;
    supplierName?: string | undefined;
    status?: string | undefined;
    createdAt?: Date;
    createdByName?: string | undefined;
    items?: ResponsePurchaseOrderItemJson[] | undefined;
}

export class ResponseRecentPurchaseOrderJson implements IResponseRecentPurchaseOrderJson {
    id?: number;
    supplierName?: string | undefined;
    status?: string | undefined;
    total?: number;
    createdAt?: Date;

    constructor(data?: IResponseRecentPurchaseOrderJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.supplierName = _data["supplierName"];
            this.status = _data["status"];
            this.total = _data["total"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseRecentPurchaseOrderJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseRecentPurchaseOrderJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["supplierName"] = this.supplierName;
        data["status"] = this.status;
        data["total"] = this.total;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseRecentPurchaseOrderJson {
    id?: number;
    supplierName?: string | undefined;
    status?: string | undefined;
    total?: number;
    createdAt?: Date;
}

export class ResponseRegisterUserJson implements IResponseRegisterUserJson {
    name?: string | undefined;
    tokens?: ResponseTokensJson;

    constructor(data?: IResponseRegisterUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.tokens = _data["tokens"] ? ResponseTokensJson.fromJS(_data["tokens"]) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseRegisterUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseRegisterUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["tokens"] = this.tokens ? this.tokens.toJSON() : undefined as any;
        return data;
    }
}

export interface IResponseRegisterUserJson {
    name?: string | undefined;
    tokens?: ResponseTokensJson;
}

export class ResponseReplenishmentItemJson implements IResponseReplenishmentItemJson {
    productId?: number;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uom?: string | undefined;
    currentStock?: number;
    reorderPoint?: number;
    dailyConsumption?: number;
    leadTimeDays?: number;
    suggestedQty?: number;
    isCritical?: boolean;
    unitPrice?: number;

    constructor(data?: IResponseReplenishmentItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.category = _data["category"];
            this.uom = _data["uom"];
            this.currentStock = _data["currentStock"];
            this.reorderPoint = _data["reorderPoint"];
            this.dailyConsumption = _data["dailyConsumption"];
            this.leadTimeDays = _data["leadTimeDays"];
            this.suggestedQty = _data["suggestedQty"];
            this.isCritical = _data["isCritical"];
            this.unitPrice = _data["unitPrice"];
        }
    }

    static fromJS(data: any): ResponseReplenishmentItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseReplenishmentItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["category"] = this.category;
        data["uom"] = this.uom;
        data["currentStock"] = this.currentStock;
        data["reorderPoint"] = this.reorderPoint;
        data["dailyConsumption"] = this.dailyConsumption;
        data["leadTimeDays"] = this.leadTimeDays;
        data["suggestedQty"] = this.suggestedQty;
        data["isCritical"] = this.isCritical;
        data["unitPrice"] = this.unitPrice;
        return data;
    }
}

export interface IResponseReplenishmentItemJson {
    productId?: number;
    sku?: string | undefined;
    name?: string | undefined;
    category?: string | undefined;
    uom?: string | undefined;
    currentStock?: number;
    reorderPoint?: number;
    dailyConsumption?: number;
    leadTimeDays?: number;
    suggestedQty?: number;
    isCritical?: boolean;
    unitPrice?: number;
}

export class ResponseReportsJson implements IResponseReportsJson {
    totalPurchaseOrders?: number;
    totalValuePurchased?: number;
    pendingPurchaseOrders?: number;
    recentOrders?: ResponseRecentPurchaseOrderJson[] | undefined;
    topSuppliers?: ResponseTopSupplierJson[] | undefined;

    constructor(data?: IResponseReportsJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalPurchaseOrders = _data["totalPurchaseOrders"];
            this.totalValuePurchased = _data["totalValuePurchased"];
            this.pendingPurchaseOrders = _data["pendingPurchaseOrders"];
            if (Array.isArray(_data["recentOrders"])) {
                this.recentOrders = [] as any;
                for (let item of _data["recentOrders"])
                    this.recentOrders!.push(ResponseRecentPurchaseOrderJson.fromJS(item));
            }
            if (Array.isArray(_data["topSuppliers"])) {
                this.topSuppliers = [] as any;
                for (let item of _data["topSuppliers"])
                    this.topSuppliers!.push(ResponseTopSupplierJson.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponseReportsJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseReportsJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalPurchaseOrders"] = this.totalPurchaseOrders;
        data["totalValuePurchased"] = this.totalValuePurchased;
        data["pendingPurchaseOrders"] = this.pendingPurchaseOrders;
        if (Array.isArray(this.recentOrders)) {
            data["recentOrders"] = [];
            for (let item of this.recentOrders)
                data["recentOrders"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.topSuppliers)) {
            data["topSuppliers"] = [];
            for (let item of this.topSuppliers)
                data["topSuppliers"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IResponseReportsJson {
    totalPurchaseOrders?: number;
    totalValuePurchased?: number;
    pendingPurchaseOrders?: number;
    recentOrders?: ResponseRecentPurchaseOrderJson[] | undefined;
    topSuppliers?: ResponseTopSupplierJson[] | undefined;
}

export class ResponseShortUserJson implements IResponseShortUserJson {
    id?: string;
    name?: string | undefined;

    constructor(data?: IResponseShortUserJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ResponseShortUserJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseShortUserJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IResponseShortUserJson {
    id?: string;
    name?: string | undefined;
}

export class ResponseStockItemJson implements IResponseStockItemJson {
    id?: number;
    productName?: string | undefined;
    warehouseName?: string | undefined;
    quantity?: number;
    updatedAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;

    constructor(data?: IResponseStockItemJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.warehouseName = _data["warehouseName"];
            this.quantity = _data["quantity"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseStockItemJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseStockItemJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["warehouseName"] = this.warehouseName;
        data["quantity"] = this.quantity;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseStockItemJson {
    id?: number;
    productName?: string | undefined;
    warehouseName?: string | undefined;
    quantity?: number;
    updatedAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
}

export class ResponseSupplierJson implements IResponseSupplierJson {
    id?: number;
    name?: string | undefined;
    contact?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    createdByName?: string | undefined;

    constructor(data?: IResponseSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.contact = _data["contact"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): ResponseSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contact"] = this.contact;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IResponseSupplierJson {
    id?: number;
    name?: string | undefined;
    contact?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    createdByName?: string | undefined;
}

export class ResponseTokensJson implements IResponseTokensJson {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    tokenId?: string | undefined;

    constructor(data?: IResponseTokensJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.tokenId = _data["tokenId"];
        }
    }

    static fromJS(data: any): ResponseTokensJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseTokensJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["tokenId"] = this.tokenId;
        return data;
    }
}

export interface IResponseTokensJson {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
    tokenId?: string | undefined;
}

export class ResponseTopSupplierJson implements IResponseTopSupplierJson {
    supplierName?: string | undefined;
    totalPurchased?: number;

    constructor(data?: IResponseTopSupplierJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.supplierName = _data["supplierName"];
            this.totalPurchased = _data["totalPurchased"];
        }
    }

    static fromJS(data: any): ResponseTopSupplierJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseTopSupplierJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supplierName"] = this.supplierName;
        data["totalPurchased"] = this.totalPurchased;
        return data;
    }
}

export interface IResponseTopSupplierJson {
    supplierName?: string | undefined;
    totalPurchased?: number;
}

export class ResponseUserProfileJson implements IResponseUserProfileJson {
    name?: string | undefined;
    email?: string | undefined;

    constructor(data?: IResponseUserProfileJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResponseUserProfileJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseUserProfileJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        return data;
    }
}

export interface IResponseUserProfileJson {
    name?: string | undefined;
    email?: string | undefined;
}

export class ResponseWarehouseJson implements IResponseWarehouseJson {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
    utilization?: number;
    createdAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
    updatedByUserId?: number | undefined;
    updatedByName?: string | undefined;
    updatedAt?: Date | undefined;

    constructor(data?: IResponseWarehouseJson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.location = _data["location"];
            this.capacity = _data["capacity"];
            this.items = _data["items"];
            this.utilization = _data["utilization"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByUserId = _data["createdByUserId"];
            this.createdByName = _data["createdByName"];
            this.updatedByUserId = _data["updatedByUserId"];
            this.updatedByName = _data["updatedByName"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ResponseWarehouseJson {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseWarehouseJson();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["capacity"] = this.capacity;
        data["items"] = this.items;
        data["utilization"] = this.utilization;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByUserId"] = this.createdByUserId;
        data["createdByName"] = this.createdByName;
        data["updatedByUserId"] = this.updatedByUserId;
        data["updatedByName"] = this.updatedByName;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IResponseWarehouseJson {
    id?: number;
    name?: string | undefined;
    location?: string | undefined;
    capacity?: number;
    items?: number;
    utilization?: number;
    createdAt?: Date;
    createdByUserId?: number;
    createdByName?: string | undefined;
    updatedByUserId?: number | undefined;
    updatedByName?: string | undefined;
    updatedAt?: Date | undefined;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}